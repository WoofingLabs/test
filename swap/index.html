
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WoofSwap - Swap</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <link rel="icon" href="https://woofingjace.com/images/elon.png" type="image/x-icon">
    <style>
        :root {
            --primary-color: #ff9100;
            --secondary-color: #ff6f61;
            --gradient-bg: linear-gradient(180deg, #1e1e2f 0%, #2a2a3d 100%);
            --card-bg: #2c2f48;
            --input-bg: #373b5c;
            --text-color: #ffffff;
            --border-radius: 15px;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Poppins', sans-serif;
            background: var(--gradient-bg);
            color: var(--text-color);
            padding: 20px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .container {
            width: 100%;
            max-width: 480px;
            background: var(--card-bg);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border-radius: var(--border-radius);
            padding: 20px;
            position: relative;
        }
        .header {
            background: linear-gradient(90deg, var(--secondary-color) 0%, var(--primary-color) 100%);
            padding: 12px;
            border-radius: var(--border-radius);
            text-align: center;
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .connect-section button {
            padding: 12px;
            background: var(--primary-color);
            color: var(--text-color);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.2s;
            margin-bottom: 10px;
        }
        .connect-section button:hover { background: #e68a00; }
        .swap-box {
            background: var(--input-bg);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            position: relative;
        }
        .balance-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #ff9100;
        }
        .token-select {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            background: var(--card-bg);
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .token-select div {
            display: flex;
            align-items: center;
        }
        .token-select img {
            width: 24px;
            height: 24px;
            margin-right: 10px;
        }
        .token-select .placeholder {
            width: 24px;
            height: 24px;
            background: #4a4f7a;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
        }
        input {
            width: 100%;
            padding: 10px;
            background: var(--input-bg);
            border: none;
            border-radius: 10px;
            color: var(--text-color);
            font-size: 1em;
            text-align: right;
        }
        .percentage-buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .percentage-buttons button {
            padding: 5px 10px;
            background: #4a4f7a;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            color: var(--text-color);
            flex: 1;
        }
        .percentage-buttons button:hover { background: #5a5f8a; }
        .switch-button {
            text-align: center;
            margin: 15px 0;
        }
        .switch-button button {
            padding: 10px;
            background: var(--primary-color);
            color: var(--text-color);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        .swap-button {
            padding: 15px;
            background: var(--primary-color);
            color: var(--text-color);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            transition: background 0.2s;
        }
        .swap-button:disabled {
            background: #4a4f7a;
            cursor: not-allowed;
        }
        .swap-button:hover:not(:disabled), .switch-button button:hover { background: #e68a00; }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        .modal-content {
            background: var(--card-bg);
            margin: 15% auto;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            border-radius: var(--border-radius);
            max-height: 70vh;
            overflow-y: auto;
        }
        .token-item {
            display: flex;
            align-items: center;
            padding: 10px;
            cursor: pointer;
            border-radius: 10px;
        }
        .token-item:hover { background: var(--input-bg); }
        .token-item img {
            width: 32px;
            height: 32px;
            margin-right: 10px;
        }
        .status {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--primary-color);
            text-align: center;
        }
        .slippage-info, .swap-note {
            font-size: 0.9em;
            color: #ff9100;
            margin-top: 5px;
            text-align: left;
        }
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #fff;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 5px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .dog-section {
            text-align: center;
            margin-top: 20px;
        }
        .dog-section img {
            width: 60px;
            height: 60px;
            margin-bottom: 10px;
        }
        .dog-message {
            font-size: 0.9em;
            color: var(--secondary-color);
            font-style: italic;
        }
        @media (max-width: 480px) {
            body { padding: 10px; }
            .container { padding: 15px; }
            .header { font-size: 1.1em; }
            .modal-content { margin: 10% auto; }
            .percentage-buttons button { padding: 5px; }
            .dog-section img { width: 50px; height: 50px; }
            .dog-message { font-size: 0.8em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">WoofSwap</div>
        <div class="connect-section">
            <button id="connectWalletButton">Connect Wallet</button>
            <div id="networkStatus" class="status">Click to connect...</div>
        </div>
        <div class="swap-box">
            <div class="balance-row">
                <span>From</span>
                <span id="fromBalance">Balance: 0</span>
            </div>
            <div class="token-select" id="fromToken">
                <div>
                    <img src="https://woofingjace.com/images/elon.png" alt="ELON">
                    <span id="fromTokenSymbol">ELON</span>
                </div>
                <span></span>
            </div>
            <input type="number" id="fromAmount" placeholder="0.0" step="0.01" oninput="calculateOutput()">
            <div class="percentage-buttons">
                <button onclick="setPercentage(25)">25%</button>
                <button onclick="setPercentage(50)">50%</button>
                <button onclick="setPercentage(75)">75%</button>
                <button onclick="setPercentage(100)">MAX</button>
            </div>
        </div>
        <div class="switch-button">
            <button onclick="switchTokens()">↓↑</button>
        </div>
        <div class="swap-box">
            <div class="balance-row">
                <span>To</span>
                <span id="toBalance">Balance: 0</span>
            </div>
            <div class="token-select" id="toToken">
                <div>
                    <div class="placeholder">?</div>
                    <span>Select a token</span>
                </div>
                <span>▼</span>
            </div>
            <div class="slippage-info">Default Slippage: 0.5%</div>
            <div class="swap-note" id="swapNote">Amount automatically calculated by WoofSwap</div>
        </div>
        <button class="swap-button" id="swapButton" onclick="swapTokens()">Swap</button>
        <div class="dog-section">
            <img src="https://woofingjace.com/images/elon.png" alt="WoofingJace">
            <div class="dog-message" id="dogMessage">"Woof! Connect your wallet to start swapping, pup!"</div>
        </div>
    </div>
    <div class="modal" id="tokenModal">
        <div class="modal-content">
            <h3>Select a token</h3>
            <div id="tokenList"></div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script>
        const tokens = [
            { address: "0x6a267196D0B330283416F19DFA0Cf75511BA83bE", symbol: "EDOG", logo: "https://woofswap.finance/image/tokens/edog.png?1" }
        ];
        const ELONToken = { address: "0x19ecB643988dB8beA1Ff528E6D91dB559b70F181", symbol: "ELON", logo: "https://woofingjace.com/images/elon.png", isNative: true };
        const routerAddress = "0xF3BC0C7acf2FBD4A4E545ce770Bf909033e2F899";
        const factoryAddress = "0x02D4707e39FcEa318E8C747141F045A1b6B89788";
        const wethAddress = "0x19ecB643988dB8beA1Ff528E6D91dB559b70F181";
        const routerAbi = [
            {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address","name":"tokenFrom","type":"address"},{"internalType":"address","name":"tokenTo","type":"address"},{"internalType":"bool","name":"stable","type":"bool"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForTokensSimple","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct Router.route[]","name":"routes","type":"tuple[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForTokensSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct Router.route[]","name":"routes","type":"tuple[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactETHForTokensSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"payable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct Router.route[]","name":"routes","type":"tuple[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForETHSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"components":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"internalType":"struct Router.route[]","name":"routes","type":"tuple[]"}],"name":"getAmountsOut","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"view","type":"function"}
        ];
        const factoryAbi = [
            {"inputs":[{"internalType":"address","name":"tokenA","type":"address"},{"internalType":"address","name":"tokenB","type":"address"},{"internalType":"bool","name":"stable","type":"bool"}],"name":"getPair","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}
        ];
        const pairAbi = [
            {"inputs":[],"name":"getReserves","outputs":[{"internalType":"uint256","name":"reserve0","type":"uint256"},{"internalType":"uint256","name":"reserve1","type":"uint256"},{"internalType":"uint32","name":"blockTimestampLast","type":"uint32"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"token0","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"token1","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"stable","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}
        ];
        const erc20Abi = [
            {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"},
            {"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"success","type":"bool"}],"type":"function"},
            {"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"type":"function"}
        ];
        const XLayer = {
            chainId: 2420,
            chainName: 'Rufus Chain',
            nativeCurrency: { name: 'ELON', symbol: 'ELON', decimals: 18 },
            rpcUrls: ['https://rufus.calderachain.xyz/http'],
            blockExplorerUrls: ['https://rufus.calderaexplorer.xyz']
        };
        let web3, account, router, factory;
        let fromToken = ELONToken;
        let toToken = null;
        let fromBalance = '0';
        let isFromELON = true;
        let isApproving = false;
        const defaultSlippage = 0.005;
        const maxPriceImpact = 0.5;

        const dogMessages = {
            connectStart: ["Woof woof! Sniffing out your wallet, hold tight, human!","Arf! Digging into Rufus Chain, let’s fetch that wallet!","Bow wow! Connecting to your stash, stay pawsitive!","Woof! I smell a wallet, let’s link it up quick!"],
            connectSuccess: ["Arf arf! You’re in, pup! Time to chase some ELONs!","Woof! Wallet’s hooked, ready to roll in Rufus Chain!","Yip yip! Connected, hooman! Let’s swap some treats!","Bow wow! Welcome aboard, let’s sniff out some swaps!"],
            connectFail: ["Grrr... Wallet slipped away, try again, hooman!","Woof? No wallet scent detected, give it another go!","Arf arf! Something barked up, retry connecting, pup!","Ruff! Wallet’s hiding, let’s dig it out again!"],
            tokenModal: ["Woof! Pick a token, let’s sniff out a juicy deal!","Arf! What treat shall we fetch today, hooman?","Bow wow! Tokens galore, choose your fave, pup!","Yip! Time to pick a token to swap, let’s go!"],
            selectToken: (symbol) => [`Arf arf! ${symbol}, huh? Smells like a tasty choice!`,`Woof! ${symbol} caught your eye? Good nose, pup!`,`Bow wow! ${symbol} it is! Let’s wag into action!`,`Yip yip! ${symbol} sounds pawsome, ready to swap?`],
            switchTokens: ["Woof woof! Flipping tokens like a Jace pro, huh?","Arf! Swapping sides, let’s keep the tail wagging!","Bow wow! Token switcheroo, you’re a clever pup!","Ruff ruff! Mixing it up, let’s see what we fetch!"],
            setPercentage: (percent) => [`Woof! ${percent}% in? You’re a bold Jace, hooman!`,`Arf arf! Going ${percent}%? Let’s dig into that swap!`,`Bow wow! ${percent}% of the stash? Pawsitively daring!`,`Yip! ${percent}%? You’re chasing big ELONs today!`],
            calcStart: ["Woof! Sniffing out the best price, hang tight!","Arf! Digging up some swap numbers, stay put, pup!","Bow wow! Crunching ELONs, I’ll fetch the output soon!","Ruff! Calculating your treat, give me a sec, hooman!"],
            calcSuccess: (amount, symbol) => [`Arf! Found ya ${amount} ${symbol}! Ready to swap, pup?`,`Woof woof! Snagged ${amount} ${symbol}, let’s roll!`,`Yip yip! Dug up ${amount} ${symbol}, happy tail wags!`,`Bow wow! ${amount} ${symbol} sniffed out, swap time!`],
            calcFail: ["Grrr... No path for these ELONs, try a new pair, pup!","Woof? Swap trail’s cold, pick another token, hooman!","Arf arf! Couldn’t fetch the output, let’s retry!","Ruff! Swap math barked up, give it another go!"],
            swapStart: ["Woof woof! Swapping time, let’s fetch those tokens!","Arf! Launching the swap, hold onto your leash, pup!","Bow wow! Trading ELONs, here we go, Jace style!","Yip! Swapping in Rufus Chain, let’s make it pawsome!"],
            swapSuccess: ["Arf arf! Swap done, you’re a WoofSwap champ, hooman!","Woof! Tokens fetched, tail-wagging success, pup!","Bow wow! Swapped like a pro, time to celebrate!","Yip yip! Swap complete, you’re the top dog now!"],
            swapFail: ["Grrr... Swap didn’t work, let’s try again, pup!","Woof? Swap got lost, retry it, clever hooman!","Arf! Token chase failed, another go, Jace friend?","Ruff ruff! Swap slipped, let’s dig it up again!"],
            swapNoToken: ["Woof? Missing a token, pup! Pick one first!","Arf arf! No treats to swap, choose a pair, hooman!","Bow wow! Where’s the token? Let’s sniff one out!","Yip! Can’t swap air, pick a token, Jace pal!"],
            swapNoAmount: ["Arf! No amount? How am I supposed to swap air?!","Woof woof! Gimme a number, pup, or we’re stuck!","Bow wow! Empty swap? Fill it up, hooman!","Ruff! Amount’s missing, let’s fetch some digits!"],
            highPriceImpact: ["Woof woof! That swap has a huge price impact, pup! Try a smaller amount!","Arf! Too many ELONs at once—price impact’s too high, hooman!","Bow wow! Swap’s too big for the pool, let’s scale it down!","Ruff! Price impact’s barking mad—reduce the amount, Jace friend!"],
            insufficientLiquidity: ["Grrr... Not enough ELONs in the pool for this swap, pup!","Woof? Pool’s too shallow—try a smaller swap, hooman!","Arf arf! Liquidity’s low, can’t fetch that many ELONs!","Ruff! Pool’s running dry—let’s try a smaller trade!"],
            approving: ["Woof! Approving your tokens, hold on, pup!","Arf! Sniffing out approval, almost there, hooman!","Bow wow! Authorizing the swap, stay pawsitive!","Ruff! Getting ready to trade, approving now!"],
            userDenied: ["Woof woof! You scared me off, hooman! Approve next time, pup!","Arf! No swap today? You’re a tricky one, let’s try again!","Bow wow! Rejected my trade? Give me a ELON next time!","Ruff ruff! You denied me, hooman! Let’s wag back later!"]
        };

        function getRandomMessage(type, param1, param2) {
            const messages = dogMessages[type];
            if (typeof messages === 'function') {
                const options = messages(param1, param2);
                return options[Math.floor(Math.random() * options.length)];
            }
            return messages[Math.floor(Math.random() * messages.length)];
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('connectWalletButton').addEventListener('click', connectWallet);
            document.getElementById('toToken').addEventListener('click', () => showTokenModal('to'));
            setupWalletListeners();
        });

        async function connectWallet() {
            const status = document.getElementById('networkStatus');
            const connectButton = document.getElementById('connectWalletButton');
            const dogMessage = document.getElementById('dogMessage');
            try {
                if (!window.ethereum) throw new Error("No wallet detected. Please install MetaMask or another wallet.");
                connectButton.disabled = true;
                status.innerText = "Connecting...";
                dogMessage.innerText = getRandomMessage('connectStart');
                web3 = new Web3(window.ethereum);
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts.length) throw new Error("No accounts found. Please unlock your wallet.");
                account = accounts[0];
                await switchToXLayer();
                router = new web3.eth.Contract(routerAbi, routerAddress);
                factory = new web3.eth.Contract(factoryAbi, factoryAddress);
                updateUIAfterConnect();
                await updateBalances();
            } catch (error) {
                status.innerText = "Failed: " + error.message;
                dogMessage.innerText = getRandomMessage('connectFail');
                console.error(error);
                resetUI();
            } finally {
                connectButton.disabled = false;
            }
        }

        async function switchToRufusChain() {
            const chainId = await web3.eth.getChainId();
            if (Number(chainId) !== 2420) {
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: "0x974" }]
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [XLayer]
                        });
                    } else {
                        throw switchError;
                    }
                }
            }
        }

        function updateUIAfterConnect() {
            const connectButton = document.getElementById('connectWalletButton');
            const status = document.getElementById('networkStatus');
            const dogMessage = document.getElementById('dogMessage');
            connectButton.textContent = `Connected: ${account.slice(0, 6)}...${account.slice(-4)}`;
            status.innerText = "Connected to Rufus Chain";
            dogMessage.innerText = getRandomMessage('connectSuccess');
        }

        function resetUI() {
            const connectButton = document.getElementById('connectWalletButton');
            const status = document.getElementById('networkStatus');
            connectButton.textContent = "Connect Wallet";
            status.innerText = "Click to connect...";
        }

        function setupWalletListeners() {
            if (!window.ethereum) return;
            window.ethereum.on('accountsChanged', async (newAccounts) => {
                if (newAccounts.length) {
                    account = newAccounts[0];
                    if (web3) {
                        await switchToXLayer();
                        router = new web3.eth.Contract(routerAbi, routerAddress);
                        factory = new web3.eth.Contract(factoryAbi, factoryAddress);
                        updateUIAfterConnect();
                        await updateBalances();
                    } else {
                        await connectWallet();
                    }
                } else {
                    web3 = null;
                    account = null;
                    router = null;
                    factory = null;
                    resetUI();
                    document.getElementById('dogMessage').innerText = getRandomMessage('connectFail');
                }
            });
            window.ethereum.on('chainChanged', async (chainId) => {
                if (parseInt(chainId, 16) !== 2420) {
                    web3 = null;
                    account = null;
                    router = null;
                    factory = null;
                    resetUI();
                    document.getElementById('networkStatus').innerText = "Wrong network. Reconnect to Rufus Chain.";
                    document.getElementById('dogMessage').innerText = "Woof! Wrong chain, pup! Switch to Rufus Chain!";
                } else if (account) {
                    await connectWallet();
                }
            });
        }

        async function updateBalances() {
            if (!web3 || !account) return;
            if (fromToken.isNative) {
                fromBalance = await web3.eth.getBalance(account);
                document.getElementById('fromBalance').innerText = `Balance: ${web3.utils.fromWei(fromBalance, 'ether')}`;
            } else {
                const tokenContract = new web3.eth.Contract(erc20Abi, fromToken.address);
                fromBalance = await tokenContract.methods.balanceOf(account).call();
                document.getElementById('fromBalance').innerText = `Balance: ${web3.utils.fromWei(fromBalance, 'ether')}`;
            }
            if (toToken) {
                let toBalance;
                if (toToken.isNative) {
                    toBalance = await web3.eth.getBalance(account);
                } else {
                    const toTokenContract = new web3.eth.Contract(erc20Abi, toToken.address);
                    toBalance = await toTokenContract.methods.balanceOf(account).call();
                }
                document.getElementById('toBalance').innerText = `Balance: ${web3.utils.fromWei(toBalance, 'ether')}`;
            }
        }

        function showTokenModal(type) {
            const modal = document.getElementById('tokenModal');
            const tokenList = document.getElementById('tokenList');
            const dogMessage = document.getElementById('dogMessage');
            tokenList.innerHTML = '';
            tokens.forEach(token => {
                const div = document.createElement('div');
                div.className = 'token-item';
                div.innerHTML = `<img src="${token.logo}" alt="${token.symbol}"><span>${token.symbol}</span>`;
                div.onclick = () => selectToken(token, type);
                tokenList.appendChild(div);
            });
            modal.style.display = 'block';
            dogMessage.innerText = getRandomMessage('tokenModal');
            modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };
        }

        function selectToken(token, type) {
            const dogMessage = document.getElementById('dogMessage');
            if (type === 'to') {
                toToken = token;
                document.getElementById('toToken').innerHTML = `<div><img src="${token.logo}" alt="${token.symbol}"><span>${token.symbol}</span></div><span>▼</span>`;
                if (isFromELON) {
                    fromToken = ELONToken;
                } else {
                    fromToken = token;
                    toToken = ELONToken;
                    document.getElementById('fromToken').innerHTML = `<div><img src="${fromToken.logo}" alt="${fromToken.symbol}"><span id="fromTokenSymbol">${fromToken.symbol}</span></div><span></span>`;
                }
            }
            document.getElementById('tokenModal').style.display = 'none';
            dogMessage.innerText = getRandomMessage('selectToken', token.symbol);
            updateBalances();
            calculateOutput();
        }

        function switchTokens() {
            const dogMessage = document.getElementById('dogMessage');
            if (!toToken) {
                document.getElementById('networkStatus').innerText = "Please select a token to swap to.";
                dogMessage.innerText = getRandomMessage('swapNoToken');
                return;
            }
            isFromELON = !isFromELON;
            [fromToken, toToken] = [toToken, fromToken];
            document.getElementById('fromToken').innerHTML = `<div><img src="${fromToken.logo}" alt="${fromToken.symbol}"><span id="fromTokenSymbol">${fromToken.symbol}</span></div><span></span>`;
            document.getElementById('toToken').innerHTML = `<div><img src="${toToken.logo}" alt="${toToken.symbol}"><span>${toToken.symbol}</span></div><span>▼</span>`;
            dogMessage.innerText = getRandomMessage('switchTokens');
            updateBalances();
            calculateOutput();
        }

        function setPercentage(percentage) {
            const dogMessage = document.getElementById('dogMessage');
            if (!fromBalance || !web3) {
                document.getElementById('networkStatus').innerText = "Please connect wallet first.";
                dogMessage.innerText = getRandomMessage('connectFail');
                return;
            }
            let amount;
            if (percentage === 100) {
                amount = web3.utils.fromWei(fromBalance, 'ether');
            } else {
                amount = web3.utils.fromWei(fromBalance, 'ether') * (percentage / 100);
            }
            if (percentage === 100 && fromToken.isNative) {
                amount = Math.max(0, amount - 0.01);
            }
            document.getElementById('fromAmount').value = amount.toString();
            dogMessage.innerText = getRandomMessage('setPercentage', percentage);
            calculateOutput();
        }

        async function calculateOutput() {
            const amountIn = document.getElementById('fromAmount').value;
            const swapNote = document.getElementById('swapNote');
            const dogMessage = document.getElementById('dogMessage');
            if (!web3 || !account || !toToken || !amountIn || amountIn <= 0) {
                swapNote.innerHTML = 'Amount automatically calculated by WoofSwap';
                return;
            }
            let amountInWei;
            try {
                amountInWei = web3.utils.toBN(web3.utils.toWei(amountIn, 'ether'));
            } catch (error) {
                swapNote.innerHTML = 'Invalid amount entered.';
                dogMessage.innerText = getRandomMessage('swapNoAmount');
                return;
            }
            swapNote.innerHTML = `Estimated output: <span class="spinner"></span>`;
            dogMessage.innerText = getRandomMessage('calcStart');
            try {
                let bestOutput = web3.utils.toBN('0');
                for (const stable of [true, false]) {
                    const pairAddress = await factory.methods.getPair(fromToken.address, toToken.address, stable).call();
                    if (pairAddress !== '0x0000000000000000000000000000000000000000') {
                        const routes = [{ from: fromToken.address, to: toToken.address, stable }];
                        const amounts = await router.methods.getAmountsOut(amountInWei, routes).call();
                        const output = web3.utils.toBN(amounts[amounts.length - 1]);
                        if (output.gt(bestOutput)) {
                            bestOutput = output;
                        }
                    }
                }
                if (bestOutput.eq(web3.utils.toBN('0'))) {
                    swapNote.innerHTML = 'No valid trading pair found.';
                    dogMessage.innerText = getRandomMessage('calcFail');
                    return;
                }
                const outputEther = parseFloat(web3.utils.fromWei(bestOutput, 'ether'));
                swapNote.innerHTML = `Estimated output: ${outputEther.toFixed(6)} ${toToken.symbol}`;
                dogMessage.innerText = getRandomMessage('calcSuccess', outputEther.toFixed(2), toToken.symbol);
            } catch (error) {
                console.error("Error calculating output:", error);
                swapNote.innerHTML = 'Error calculating output.';
                dogMessage.innerText = getRandomMessage('calcFail');
            }
        }

        async function approveToken(tokenAddress, amount) {
            if (tokenAddress === wethAddress && fromToken.isNative) return;
            const tokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);
            const allowance = await tokenContract.methods.allowance(account, routerAddress).call();
            if (web3.utils.toBN(allowance).lt(web3.utils.toBN(amount))) {
                const swapButton = document.getElementById('swapButton');
                const dogMessage = document.getElementById('dogMessage');
                isApproving = true;
                swapButton.textContent = "Authorizing...";
                swapButton.disabled = true;
                dogMessage.innerText = getRandomMessage('approving');
                await tokenContract.methods.approve(routerAddress, amount).send({ from: account });
                document.getElementById('networkStatus').innerText = "Token approved";
                isApproving = false;
                swapButton.textContent = "Swap";
                swapButton.disabled = false;
                dogMessage.innerText = "Woof! Tokens approved, ready to swap!";
            }
        }

        async function swapTokens() {
            const dogMessage = document.getElementById('dogMessage');
            const status = document.getElementById('networkStatus');
            const swapButton = document.getElementById('swapButton');
            if (isApproving) return;
            if (!web3 || !account || !toToken) {
                status.innerText = "Please connect wallet and select tokens.";
                dogMessage.innerText = getRandomMessage('swapNoToken');
                return;
            }
            const amountIn = document.getElementById('fromAmount').value;
            if (!amountIn || amountIn <= 0) {
                status.innerText = "Please enter a valid amount.";
                dogMessage.innerText = getRandomMessage('swapNoAmount');
                return;
            }
            let amountInWei;
            try {
                amountInWei = web3.utils.toBN(web3.utils.toWei(amountIn, 'ether'));
            } catch (error) {
                status.innerText = "Invalid amount entered.";
                dogMessage.innerText = getRandomMessage('swapNoAmount');
                console.error("Amount conversion error:", error);
                return;
            }
            if (!fromToken.isNative) {
                const tokenContract = new web3.eth.Contract(erc20Abi, fromToken.address);
                const tokenBalance = await tokenContract.methods.balanceOf(account).call();
                if (web3.utils.toBN(tokenBalance).lt(amountInWei)) {
                    status.innerText = "Insufficient token balance.";
                    dogMessage.innerText = "Woof! Not enough ELONs to swap, pup!";
                    return;
                }
            }
            const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
            let bestStable = false;
            let bestOutput = web3.utils.toBN('0');
            let routes;
            try {
                for (const stable of [true, false]) {
                    const pairAddress = await factory.methods.getPair(fromToken.address, toToken.address, stable).call();
                    if (pairAddress !== '0x0000000000000000000000000000000000000000') {
                        const tempRoutes = [{ from: fromToken.address, to: toToken.address, stable }];
                        const amounts = await router.methods.getAmountsOut(amountInWei, tempRoutes).call();
                        const output = web3.utils.toBN(amounts[amounts.length - 1]);
                        if (output.gt(bestOutput)) {
                            bestOutput = output;
                            bestStable = stable;
                            routes = tempRoutes;
                        }
                    }
                }
                if (bestOutput.eq(web3.utils.toBN('0')) || !routes) {
                    status.innerText = "No valid trading pair found.";
                    dogMessage.innerText = getRandomMessage('calcFail');
                    return;
                }
                const pairAddress = await factory.methods.getPair(fromToken.address, toToken.address, bestStable).call();
                const pairContract = new web3.eth.Contract(pairAbi, pairAddress);
                const reserves = await pairContract.methods.getReserves().call();
                const token0 = await pairContract.methods.token0().call();
                const reserveFrom = token0 === fromToken.address ? reserves.reserve0 : reserves.reserve1;
                const reserveTo = token0 === fromToken.address ? reserves.reserve1 : reserves.reserve0;
                const reserveFromBN = web3.utils.toBN(reserveFrom);
                const reserveToBN = web3.utils.toBN(reserveTo);
                const priceImpact = amountInWei.mul(web3.utils.toBN(100)).div(reserveFromBN.add(amountInWei));
                if (priceImpact.gt(web3.utils.toBN(maxPriceImpact * 100))) {
                    status.innerText = `Price impact too high (${priceImpact.toString()}%).`;
                    dogMessage.innerText = getRandomMessage('highPriceImpact');
                    return;
                }
                if (bestOutput.gt(reserveToBN)) {
                    status.innerText = `Insufficient liquidity in pool.`;
                    dogMessage.innerText = getRandomMessage('insufficientLiquidity');
                    return;
                }
                const slippageFactor = web3.utils.toBN(1000 - defaultSlippage * 1000);
                const amountOutMin = bestOutput.mul(slippageFactor).div(web3.utils.toBN(1000));
                swapButton.disabled = true;
                status.innerText = "Processing swap...";
                dogMessage.innerText = getRandomMessage('swapStart');
                if (!fromToken.isNative) {
                    await approveToken(fromToken.address, amountInWei);
                }
                if (fromToken.isNative) {
                    await router.methods.swapExactETHForTokensSupportingFeeOnTransferTokens(
                        amountOutMin.toString(),
                        routes,
                        account,
                        deadline
                    ).send({ from: account, value: amountInWei });
                } else {
                    await router.methods.swapExactTokensForETHSupportingFeeOnTransferTokens(
                        amountInWei.toString(),
                        amountOutMin.toString(),
                        routes,
                        account,
                        deadline
                    ).send({ from: account });
                }
                status.innerText = "Swap successful!";
                dogMessage.innerText = getRandomMessage('swapSuccess');
                document.getElementById('fromAmount').value = '';
                await updateBalances();
            } catch (error) {
                console.error("Swap failed:", error);
                let errorMessage = error.message || "Unknown error";
                if (error.message.includes("User denied transaction signature")) {
                    errorMessage = "User denied transaction signature.";
                    dogMessage.innerText = getRandomMessage('userDenied');
                } else if (error.message.includes("INSUFFICIENT_OUTPUT_AMOUNT") || error.message.includes("EXCESSIVE_INPUT_AMOUNT")) {
                    errorMessage = "Swap failed: Price impact or slippage too high.";
                    dogMessage.innerText = "Woof! Swap failed—too much price impact or slippage.";
                } else if (error.message.includes("INSUFFICIENT_LIQUIDITY")) {
                    errorMessage = "Swap failed: Insufficient liquidity in the pool.";
                    dogMessage.innerText = getRandomMessage('insufficientLiquidity');
                } else {
                    dogMessage.innerText = getRandomMessage('swapFail');
                }
                status.innerText = errorMessage;
            } finally {
                swapButton.disabled = false;
            }
        }
    </script>
</body>
</html>
